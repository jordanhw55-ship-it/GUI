import tkinter as tk
from tkinter import filedialog, messagebox
from PIL import Image, ImageTk, ImageDraw
import math

# --- CONFIGURATION ---
HIGHLIGHT_COLOR = "cyan"
INITIAL_BRUSH_RADIUS = 15
INITIAL_DIFFERENCE_THRESHOLD = 50
INITIAL_DRAW_SKIP_THRESHOLD = 5 
PREVIEW_ERASER_RADIUS_PIXELS = 10 # Fixed brush size for detailed erasure in the preview
REDRAW_THROTTLE_MS = 50 # Maximum 20 FPS redraw rate during dragging

def color_distance(c1, c2):
    """Calculates the Euclidean distance between two RGB(A) tuples (only checking RGB)."""
    r_diff = c1[0] - c2[0]
    g_diff = c1[1] - c2[1]
    b_diff = c1[2] - c2[2]
    return math.sqrt(r_diff**2 + g_diff**2 + b_diff**2)

class BorderToolGUI(tk.Frame):
    def __init__(self, master=None):
        super().__init__(master)
        self.master.title("WC3 Border Tool Concept")
        self.pack(padx=10, pady=10)

        # Core Image Data
        self.img = None
        self.tk_img = None
        self.canvas_img = None
        
        # Scaling factors for main canvas
        self.scale_x = 1.0
        self.scale_y = 1.0
        
        # Source of truth: Stores detected border points as (original_img_x, original_img_y)
        self.raw_border_points = [] 
        
        # Tkinter variables for user-controlled settings
        self.brush_radius_var = tk.IntVar(value=INITIAL_BRUSH_RADIUS)
        self.diff_threshold_var = tk.IntVar(value=INITIAL_DIFFERENCE_THRESHOLD)
        self.draw_skip_threshold_var = tk.IntVar(value=INITIAL_DRAW_SKIP_THRESHOLD)
        
        # Preview Zoom Control
        self.preview_scale_var = tk.DoubleVar(value=1.0) 

        # State variables
        self.is_erasing = tk.BooleanVar(value=False)
        self.cursor_circle = None 
        self.preview_cursor_circle = None 
        self.last_drawn_x = -1
        self.last_drawn_y = -1
        self.redraw_scheduled = False # Flag for redraw throttling
        self.status_message = tk.StringVar(value="Draw mode active. Click or drag to detect border.")
        
        self.create_widgets()
        self.load_placeholder_image()

    def create_widgets(self):
        # Top Control Frame (Buttons)
        control_frame = tk.Frame(self)
        control_frame.pack(pady=5)

        tk.Label(control_frame, text="Smart Border Tool", font=('Arial', 14, 'bold')).pack(side=tk.LEFT, padx=10)
        
        tk.Button(control_frame, text="Load Image", command=self.open_image,
                  bg='#e0f7fa', fg='#006064').pack(side=tk.LEFT, padx=5)

        tk.Button(control_frame, text="Clear All", command=self.clear_canvas,
                  bg='#ffe0b2', fg='#e65100').pack(side=tk.LEFT, padx=5)
                  
        tk.Button(control_frame, text="Reset Settings", command=self.reset_all_settings,
                  bg='#cfd8dc', fg='#37474f').pack(side=tk.LEFT, padx=5)

        self.toggle_button = tk.Button(control_frame, text="Mode: Draw", command=self.toggle_mode,
                                       bg='#a5d6a7', fg='#1b5e20')
        self.toggle_button.pack(side=tk.LEFT, padx=5)

        # Slider Controls Frame
        slider_frame = tk.Frame(self)
        slider_frame.pack(pady=10, fill='x')

        # Brush Radius Control
        tk.Label(slider_frame, text="Brush Size (Radius):").pack(side=tk.LEFT, padx=5)
        tk.Scale(slider_frame, from_=5, to=50, orient=tk.HORIZONTAL, variable=self.brush_radius_var,
            command=self.update_brush_size_feedback).pack(side=tk.LEFT, padx=10, fill='x', expand=True)

        # Sensitivity Control
        tk.Label(slider_frame, text="Sensitivity (Threshold):").pack(side=tk.LEFT, padx=5)
        tk.Scale(slider_frame, from_=10, to=100, orient=tk.HORIZONTAL, variable=self.diff_threshold_var
        ).pack(side=tk.LEFT, padx=10, fill='x', expand=True)

        # Latency/Detail Control
        tk.Label(slider_frame, text="Latency (Skip Pixels):").pack(side=tk.LEFT, padx=5)
        tk.Scale(slider_frame, from_=1, to=15, orient=tk.HORIZONTAL, variable=self.draw_skip_threshold_var,
            command=lambda v: self.status_message.set(f"Draw Skip set to: {self.draw_skip_threshold_var.get()} pixels.")
        ).pack(side=tk.LEFT, padx=10, fill='x', expand=True)


        # --- CANVAS AND PREVIEW LAYOUT ---
        canvas_frame = tk.Frame(self)
        canvas_frame.pack(pady=10)

        # Main Canvas (Image + Highlighted Border)
        main_canvas_label = tk.Label(canvas_frame, text="Main Image (Detection & Drawing)")
        main_canvas_label.pack()
        self.canvas = tk.Canvas(canvas_frame, width=400, height=400, bg='gray')
        self.canvas.pack(side=tk.LEFT, padx=10)
        
        self.canvas.bind("<Button-1>", self.on_mouse_down) 
        self.canvas.bind("<B1-Motion>", self.on_mouse_drag)
        self.canvas.bind("<ButtonRelease-1>", self.on_mouse_up)
        self.canvas.bind("<Motion>", self.on_mouse_move)
        self.canvas.bind("<Leave>", self.on_mouse_leave)

        # Preview Canvas (Zoomable Border-Only View)
        preview_controls_frame = tk.Frame(canvas_frame)
        preview_controls_frame.pack(side=tk.LEFT, padx=10, fill='y')

        tk.Label(preview_controls_frame, text="Border Preview (Zoomable Eraser)").pack()
        
        # Zoom Slider for Preview
        tk.Label(preview_controls_frame, text="Zoom Scale:").pack()
        tk.Scale(
            preview_controls_frame, 
            from_=0.5, to=5.0, resolution=0.1, 
            orient=tk.HORIZONTAL, 
            variable=self.preview_scale_var,
            command=self.update_preview_canvas
        ).pack(fill='x')

        self.preview_canvas = tk.Canvas(preview_controls_frame, width=400, height=350, bg='#333333', highlightthickness=1, highlightbackground=HIGHLIGHT_COLOR)
        self.preview_canvas.pack()
        
        # Bindings for preview erasure and cursor
        self.preview_canvas.bind("<Button-1>", self.on_preview_down)
        self.preview_canvas.bind("<B1-Motion>", self.on_preview_drag)
        self.preview_canvas.bind("<ButtonRelease-1>", self.on_preview_up)
        self.preview_canvas.bind("<Motion>", self.on_preview_move) 
        self.preview_canvas.bind("<Leave>", self.on_preview_leave) 

        # Status Label
        tk.Label(self, textvariable=self.status_message, fg='#1565c0').pack(pady=5)
        
        # Initialize cursors once after canvases are created
        self.ensure_cursor_circle_exists()
        self.ensure_preview_cursor_circle_exists()

    # --- Lag Reduction (Throttling) Methods ---
    def deferred_redraw(self):
        """Redraws the highlights on both canvases after a throttle delay."""
        if not self.winfo_exists():
            return
            
        self.update_main_canvas_highlights()
        self.update_preview_canvas()
        self.redraw_scheduled = False
        self.status_message.set(f"Total points: {len(self.raw_border_points)}. Redraw complete.")

    # --- Core Tool Logic ---

    def update_main_canvas_highlights(self):
        """Redraws all highlights on the main canvas based on raw_border_points."""
        self.canvas.delete("highlight") # Clear existing highlights

        for raw_x, raw_y in self.raw_border_points:
            # Convert raw image coords back to main canvas coords for drawing
            canvas_px = int(raw_x * self.scale_x)
            canvas_py = int(raw_y * self.scale_y)
            
            self.canvas.create_oval(
                canvas_px, canvas_py, canvas_px + 2, canvas_py + 2, 
                fill=HIGHLIGHT_COLOR, outline="", 
                tags="highlight"
            )

    def update_preview_canvas(self, *args):
        """Redraws the stored border points on the preview canvas with the current zoom scale."""
        if not self.raw_border_points:
            self.preview_canvas.delete("preview_dot")
            return

        scale = self.preview_scale_var.get()
        preview_w = self.preview_canvas.winfo_width()
        preview_h = self.preview_canvas.winfo_height()

        if self.img:
            img_w, img_h = self.img.size
        else:
            return

        # Simple Center Calculation (Focuses on the center of the image space)
        center_x = img_w / 2
        center_y = img_h / 2

        # Delete old dots
        self.preview_canvas.delete("preview_dot") # Only delete dots, keep cursor (tag: preview_brush)
        
        dots_drawn = 0
        for raw_x, raw_y in self.raw_border_points:
            # 1. Translate point relative to image center
            rel_x = raw_x - center_x
            rel_y = raw_y - center_y

            # 2. Apply zoom scale
            zoom_x = rel_x * scale
            zoom_y = rel_y * scale
            
            # 3. Translate point to preview canvas center
            preview_x = zoom_x + preview_w / 2
            preview_y = zoom_y + preview_h / 2
            
            # Draw point (2x2 pixel point)
            self.preview_canvas.create_oval(
                preview_x, preview_y, preview_x + 2, preview_y + 2,
                fill=HIGHLIGHT_COLOR, outline="",
                tags="preview_dot"
            )
            dots_drawn += 1
            
        # Update status only if explicitly called by a slider change, otherwise wait for deferred_redraw
        if not self.redraw_scheduled:
             self.status_message.set(f"Preview updated. Dots shown: {dots_drawn}. Zoom: {scale:.1f}x")

    def process_detection_at_point(self, event, defer_redraw=False):
        """Detects borders, draws them on main canvas, and adds them to raw_border_points."""
        brush_radius = self.brush_radius_var.get()
        diff_threshold = self.diff_threshold_var.get()
        
        # Convert canvas coordinates back to original image coordinates
        img_x_center = int(event.x / self.scale_x)
        img_y_center = int(event.y / self.scale_y)

        try:
            start_pixel = self.img.getpixel((img_x_center, img_y_center))
        except IndexError:
            return

        
        newly_detected_raw_coords = set()
        
        for dx in range(-brush_radius, brush_radius + 1):
            for dy in range(-brush_radius, brush_radius + 1):
                x, y = img_x_center + dx, img_y_center + dy
                
                if 0 <= x < self.img.size[0] and 0 <= y < self.img.size[1]:
                    current_pixel = self.img.getpixel((x, y))
                    is_edge = False
                    
                    for nx in [-1, 0, 1]:
                        for ny in [-1, 0, 1]:
                            if nx == 0 and ny == 0: continue
                            
                            neighbor_x, neighbor_y = x + nx, y + ny
                            
                            if 0 <= neighbor_x < self.img.size[0] and 0 <= neighbor_y < self.img.size[1]:
                                neighbor_pixel = self.img.getpixel((neighbor_x, neighbor_y))
                                
                                alpha_diff = abs(current_pixel[3] - neighbor_pixel[3])
                                color_dist = color_distance(current_pixel, neighbor_pixel)
                                
                                if alpha_diff > 200 or color_dist > 4.0 * diff_threshold:
                                    is_edge = True
                                    break
                        if is_edge:
                            break
                            
                    if is_edge:
                        # Store raw coordinates, only adding unique points
                        newly_detected_raw_coords.add((x, y))


        # Update the master list of points
        points_added = 0
        for point in newly_detected_raw_coords:
            if point not in self.raw_border_points:
                self.raw_border_points.append(point)
                points_added += 1

        if not defer_redraw:
            # Redraw both views for synchronization only if not deferred (e.g., single click)
            self.update_main_canvas_highlights()
            self.update_preview_canvas()
            self.status_message.set(f"Drawing... added {points_added} new points. Total: {len(self.raw_border_points)}")
        else:
            self.status_message.set(f"Drawing... Added {points_added} new points. Total: {len(self.raw_border_points)}. Redraw pending.")


    def process_preview_erasure(self, event, defer_redraw=False):
        """Erases points from the raw_border_points list based on the zoomed preview brush."""
        if not self.raw_border_points: return

        scale = self.preview_scale_var.get()
        if scale == 0: return # Avoid division by zero
        
        preview_w = self.preview_canvas.winfo_width()
        preview_h = self.preview_canvas.winfo_height()
        
        if self.img is None: return
        img_w, img_h = self.img.size
        center_x = img_w / 2
        center_y = img_h / 2
        
        # 1. Determine center of erasure in ORIGINAL IMAGE coordinates
        zoom_x = event.x - preview_w / 2
        zoom_y = event.y - preview_h / 2
        
        img_x_center = (zoom_x / scale) + center_x
        img_y_center = (zoom_y / scale) + center_y

        # 2. Determine erasure radius in ORIGINAL IMAGE coordinates
        # Fixed preview eraser size (in preview canvas pixels) divided by the zoom scale.
        img_eraser_radius = PREVIEW_ERASER_RADIUS_PIXELS / scale 
        
        # 3. Find and remove points from raw_border_points
        new_raw_border_points = []
        erased_count = 0
        
        for raw_x, raw_y in self.raw_border_points:
            # Check distance in original image space
            dist = math.sqrt(
                (raw_x - img_x_center)**2 + 
                (raw_y - img_y_center)**2
            )
            
            if dist > img_eraser_radius:
                new_raw_border_points.append((raw_x, raw_y))
            else:
                erased_count += 1
                
        self.raw_border_points = new_raw_border_points

        if not defer_redraw:
            # Redraw both views for synchronization only if not deferred (e.g., single click)
            self.update_main_canvas_highlights()
            self.update_preview_canvas()
            self.status_message.set(f"Preview Eraser: Removed {erased_count} border points. Total: {len(self.raw_border_points)}")
        else:
            self.status_message.set(f"Preview Eraser: Removed {erased_count} border points. Total: {len(self.raw_border_points)}. Redraw pending.")
        
    def process_erasure_at_point(self, event, defer_redraw=False):
        """Removes points from the raw_border_points list based on the main canvas brush location."""
        if not self.raw_border_points:
            self.canvas.delete("highlight")
            return
            
        brush_radius_canvas = self.brush_radius_var.get()
        
        # Convert canvas center point to original image coordinates
        img_x_center = event.x / self.scale_x
        img_y_center = event.y / self.scale_y

        # Convert canvas brush radius to original image pixel radius
        img_eraser_radius = brush_radius_canvas / self.scale_x 
        
        # Find and remove points within the erasure circle in raw_border_points
        new_raw_border_points = []
        erased_count = 0
        
        for raw_x, raw_y in self.raw_border_points:
            # Check distance in original image space
            dist = math.sqrt(
                (raw_x - img_x_center)**2 + 
                (raw_y - img_y_center)**2
            )
            
            if dist > img_eraser_radius:
                new_raw_border_points.append((raw_x, raw_y))
            else:
                erased_count += 1
                
        self.raw_border_points = new_raw_border_points

        if not defer_redraw:
            # Redraw both views for synchronization only if not deferred (e.g., single click)
            self.update_main_canvas_highlights()
            self.update_preview_canvas()
            self.status_message.set(f"Main Eraser: Removed {erased_count} border points. Total: {len(self.raw_border_points)}")
        else:
            self.status_message.set(f"Main Eraser: Removed {erased_count} border points. Total: {len(self.raw_border_points)}. Redraw pending.")

    # --- Mouse Event Handlers (Main Canvas) ---
    def on_mouse_down(self, event):
        if self.img is None:
            self.status_message.set("Error: Please load an image first.")
            return

        self.last_drawn_x = event.x
        self.last_drawn_y = event.y
        
        # Immediate action on click down
        if self.is_erasing.get():
            self.process_erasure_at_point(event)
        else:
            self.process_detection_at_point(event)

    def on_mouse_drag(self, event):
        if self.img is None:
            return
        
        self.on_mouse_move(event) 

        draw_skip = self.draw_skip_threshold_var.get()
        distance = math.sqrt((event.x - self.last_drawn_x)**2 + (event.y - self.last_drawn_y)**2)

        if distance < draw_skip:
            return
        
        self.last_drawn_x = event.x
        self.last_drawn_y = event.y

        if self.is_erasing.get():
            self.process_erasure_at_point(event, defer_redraw=True) # Defer redraw
        else:
            self.process_detection_at_point(event, defer_redraw=True) # Defer redraw
        
        # Throttle the actual expensive redraw operation
        if not self.redraw_scheduled:
            self.redraw_scheduled = True
            self.master.after(REDRAW_THROTTLE_MS, self.deferred_redraw)
            
    def on_mouse_up(self, event):
        """Ensures final state is immediately drawn after dragging stops."""
        if self.redraw_scheduled:
            self.master.after_cancel(self.deferred_redraw) # Cancel any pending deferred call
            self.redraw_scheduled = False
        self.deferred_redraw()


    # --- Mouse Event Handlers (Preview Canvas) ---
    def on_preview_down(self, event):
        """Starts erasure in the zoomed preview."""
        self.on_preview_move(event) # Update cursor immediately
        self.process_preview_erasure(event)

    def on_preview_drag(self, event):
        """Allows continuous erasure in the zoomed preview, with throttling."""
        self.on_preview_move(event) # Update cursor position while dragging
        self.process_preview_erasure(event, defer_redraw=True)

        if not self.redraw_scheduled:
            self.redraw_scheduled = True
            self.master.after(REDRAW_THROTTLE_MS, self.deferred_redraw)
            
    def on_preview_up(self, event):
        """Ensures final state is immediately drawn after preview dragging stops."""
        if self.redraw_scheduled:
            self.master.after_cancel(self.deferred_redraw)
            self.redraw_scheduled = False
        self.deferred_redraw()

    # --- Cursor Management ---
    def toggle_mode(self):
        current_state = self.is_erasing.get()
        self.is_erasing.set(not current_state)
        
        if self.is_erasing.get():
            self.toggle_button.config(text="Mode: Erase", bg='#ef9a9a', fg='#b71c1c')
            self.status_message.set("Eraser mode active. Drag to clear highlights.")
        else:
            self.toggle_button.config(text="Mode: Draw", bg='#a5d6a7', fg='#1b5e20')
            self.status_message.set("Draw mode active. Click or drag to detect border.")
        
        self._update_cursor_properties()

    def update_brush_size_feedback(self, value):
        self.status_message.set(f"Brush Radius set to: {self.brush_radius_var.get()}")
        self._update_cursor_properties()

    # Main Canvas Cursor
    def ensure_cursor_circle_exists(self):
        if self.cursor_circle is None:
            self.cursor_circle = self.canvas.create_oval(
                -10, -10, -10, -10, 
                outline=HIGHLIGHT_COLOR, width=1, tags="brush", state='hidden'
            )
            
    def _update_cursor_properties(self):
        # Update main canvas cursor appearance based on mode
        outline_color = 'red' if self.is_erasing.get() else HIGHLIGHT_COLOR
        outline_width = 2 if self.is_erasing.get() else 1
        
        try:
            if self.cursor_circle:
                self.canvas.itemconfigure(self.cursor_circle, 
                                        outline=outline_color, width=outline_width, state='normal')
        except:
            # Recreate if it somehow got deleted
            self.cursor_circle = None
            self.ensure_cursor_circle_exists()
            if self.cursor_circle:
                 self.canvas.itemconfigure(self.cursor_circle, 
                                    outline=outline_color, width=outline_width, state='normal')

    def on_mouse_move(self, event):
        self._update_cursor_properties()
        r = self.brush_radius_var.get()
        x1, y1 = event.x - r, event.y - r
        x2, y2 = event.x + r, event.y + r
        if self.cursor_circle:
             self.canvas.coords(self.cursor_circle, x1, y1, x2, y2)

    def on_mouse_leave(self, event):
        if self.cursor_circle is not None:
             self.canvas.itemconfigure(self.cursor_circle, state='hidden')
             
    # Preview Canvas Cursor (Defensive Re-creation added here)
    def ensure_preview_cursor_circle_exists(self):
        if self.preview_cursor_circle is None:
            # Create object with unique tag "preview_brush"
            self.preview_cursor_circle = self.preview_canvas.create_oval(
                -10, -10, -10, -10, 
                outline='red', width=2, tags="preview_brush", state='hidden'
            )

    def on_preview_move(self, event):
        r = PREVIEW_ERASER_RADIUS_PIXELS
        x1, y1 = event.x - r, event.y - r
        x2, y2 = event.x + r, event.y + r
        
        try:
            # 1. Try to update the existing cursor object
            if self.preview_cursor_circle:
                self.preview_canvas.coords(self.preview_cursor_circle, x1, y1, x2, y2)
                self.preview_canvas.itemconfigure(self.preview_cursor_circle, state='normal')
            else:
                # If ID is None, call the creation function and retry
                self.ensure_preview_cursor_circle_exists()
                self.on_preview_move(event) # Recursive call to retry update
                
        except tk.TclError:
            # 2. If the update fails (TclError usually means the object ID is gone),
            #    recreate the cursor object and try the update again.
            print("Preview cursor object invalid, recreating.")
            self.preview_cursor_circle = None
            self.ensure_preview_cursor_circle_exists()
            # If successfully recreated, the recursive call above will handle the update.
            if self.preview_cursor_circle:
                self.preview_canvas.coords(self.preview_cursor_circle, x1, y1, x2, y2)
                self.preview_canvas.itemconfigure(self.preview_cursor_circle, state='normal')

            
    def on_preview_leave(self, event):
        if self.preview_cursor_circle is not None:
             self.preview_canvas.itemconfigure(self.preview_cursor_circle, state='hidden')

    # --- Utility Methods ---
    def clear_canvas(self):
        """Removes all highlight drawings and resets coordinate lists."""
        self.canvas.delete("highlight")
        self.raw_border_points = [] # Clear stored points
        self.update_preview_canvas() # Clear the preview
        self.status_message.set("Highlights cleared. Click or drag to detect a new border.")
        
    def reset_all_settings(self):
        """Resets all settings and clears drawings."""
        self.clear_canvas()
        self.brush_radius_var.set(INITIAL_BRUSH_RADIUS)
        self.diff_threshold_var.set(INITIAL_DIFFERENCE_THRESHOLD)
        self.draw_skip_threshold_var.set(INITIAL_DRAW_SKIP_THRESHOLD)
        self.preview_scale_var.set(1.0) # Reset zoom scale
        
        if self.is_erasing.get():
             self.toggle_mode()
        self._update_cursor_properties()
        self.status_message.set("Settings reset. Click or drag on the image to detect the border.")

    # --- Image Loading ---
    def generate_sample_image(self):
        size = 400
        img = Image.new('RGBA', (size, size), (0, 0, 0, 0))
        draw = ImageDraw.Draw(img)
        circle_radius = 100
        center = size // 2
        # A red circle that contrasts sharply with the default black background
        draw.ellipse([center - circle_radius, center - circle_radius, 
                      center + circle_radius, center + circle_radius], 
                     fill=(255, 0, 0, 255))
        return img

    def load_placeholder_image(self):
        self.img = self.generate_sample_image()
        self.update_canvas_image()

    def open_image(self):
        filepath = filedialog.askopenfilename(
            filetypes=[("Image files", "*.png;*.jpg;*.jpeg"), ("All files", "*.*")]
        )
        if filepath:
            try:
                self.img = Image.open(filepath).convert("RGBA")
                self.update_canvas_image()
            except Exception as e:
                messagebox.showerror("Error", f"Could not load image: {e}")

    def update_canvas_image(self):
        """Recalculates scale factors and displays the scaled image copy."""
        if self.img:
            img_w, img_h = self.img.size
            # Use fixed canvas size for stable layout
            canvas_w, canvas_h = 400, 400
            
            # Calculate scale factors for coordinate conversion
            self.scale_x = canvas_w / img_w
            self.scale_y = canvas_h / img_h
            
            # Resize *only* the display copy
            display_img = self.img.resize((canvas_w, canvas_h), Image.NEAREST)
            
            self.tk_img = ImageTk.PhotoImage(display_img)
            self.canvas.delete("all")
            self.cursor_circle = None 

            self.canvas_img = self.canvas.create_image(0, 0, anchor=tk.NW, image=self.tk_img)

            self.ensure_cursor_circle_exists()
            self.clear_canvas() # Clear existing dots when image changes

# --- Main Application Loop ---
if __name__ == '__main__':
    root = tk.Tk()
    app = BorderToolGUI(master=root)
    root.update_idletasks() 
    app.update_canvas_image() 
    app.mainloop()